package com.example.upbitautotrade.viewmodel;

import android.app.Activity;
import android.app.Application;
import android.content.Context;

import androidx.lifecycle.AndroidViewModel;
import androidx.lifecycle.LiveData;
import androidx.lifecycle.MutableLiveData;
import androidx.lifecycle.Transformations;

import com.example.upbitautotrade.UpBitLogInPreferences;
import com.example.upbitautotrade.api.UpBitFetcher;
import com.example.upbitautotrade.model.Accounts;
import com.example.upbitautotrade.model.MarketInfo;

import java.util.List;

public class UpBitViewModel extends AndroidViewModel {
    private final String TAG = "UpBitViewModel";

    public static final String LOGIN = "LogIn";

    private final LiveData<Throwable> mErrorLiveData;
    private final MutableLiveData<Boolean> mSearchAccountsInfo;
    private final LiveData<List<Accounts>> mResultAccountsInfo;
    private final MutableLiveData<Boolean> mSearchMarketsInfo;
    private final LiveData<List<MarketInfo>> mResultMarketsInfo;

    protected UpBitFetcher mUpBitFetcher;
    private boolean mIsSuccessfulConnection;
    private String mAccessKey = null;
    private String mSecretKey = null;

    private LoginState mListener;
    public RequestErrorListener mRequestErrorListener;

    protected Activity mActivity;

    public interface LoginState {
        void onLoginState(boolean isLogin);
    }

    public interface RequestErrorListener {
        void shortMoney(String uuid);
        void deleteError(String uuid);
    }

    public UpBitViewModel(Application application) {
        super(application);
        initFetcher(application.getApplicationContext());
        mErrorLiveData = mUpBitFetcher.getErrorLiveData();

        mSearchAccountsInfo = new MutableLiveData<>();
        mResultAccountsInfo = Transformations.switchMap(
                mSearchAccountsInfo, input -> mUpBitFetcher.getAccounts(input)
        );

        mSearchMarketsInfo = new MutableLiveData<>();
        mResultMarketsInfo = Transformations.switchMap(
                mSearchMarketsInfo, input -> mUpBitFetcher.getMarketInfo(input)
        );
    }

    protected void initFetcher(Context context) {
        mUpBitFetcher = new UpBitFetcher(new UpBitFetcher.ConnectionState() {
            @Override
            public void onConnection(boolean isConnect) {
                mIsSuccessfulConnection = isConnect;
                if (isConnect) {
                    UpBitLogInPreferences.setStoredKey(context.getApplicationContext(), UpBitLogInPreferences.ACCESS_KEY, mAccessKey);
                    UpBitLogInPreferences.setStoredKey(context.getApplicationContext(), UpBitLogInPreferences.SECRET_KEY, mSecretKey);
                }
                mListener.onLoginState(isConnect);
            }

            @Override
            public void deleteError(String uuid) {

            }

            @Override
            public void shortMoney(String uuid) {

            }
        });
    }

    public void setActivity(Activity activity) {
        mActivity = activity;
        mUpBitFetcher.setActivity(activity);
    }

    public void setKey(String accessKey, String secretKey) {
        if (mUpBitFetcher != null) {
            mUpBitFetcher.makeRetrofit(accessKey, secretKey);
        }
        mAccessKey = accessKey;
        mSecretKey = secretKey;
    }

    public void setOnListener(LoginState listener) {
        mListener = listener;
    }

    public void setOnPostErrorListener(RequestErrorListener listener) {
        mRequestErrorListener = listener;
    }

    public void searchAccountsInfo(boolean isLogIn) {
        mSearchAccountsInfo.setValue(isLogIn);
    }

    public LiveData<List<Accounts>> getAccountsInfo() {
        return mResultAccountsInfo;
    }

    public void searchMarketsInfo(boolean isDetails) {
        mSearchMarketsInfo.setValue(isDetails);
    }

    public LiveData<List<MarketInfo>> getMarketsInfo() {
        return mResultMarketsInfo;
    }

    public LiveData<Throwable> getErrorLiveData() {
        return mErrorLiveData;
    }
}
